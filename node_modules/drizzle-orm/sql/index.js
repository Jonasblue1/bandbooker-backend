"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fillPlaceholders = exports.placeholder = exports.Placeholder = exports.sql = exports.param = exports.Param = exports.noopMapper = exports.noopEncoder = exports.noopDecoder = exports.name = exports.Name = exports.SQL = exports.isSQLWrapper = exports.FakePrimitiveParam = void 0;
const subquery_1 = require("../subquery");
const column_1 = require("../column");
const table_1 = require("../table");
/**
 * This class is used to indicate a primitive param value that is used in `sql` tag.
 * It is only used on type level and is never instantiated at runtime.
 * If you see a value of this type in the code, its runtime value is actually the primitive param value.
 */
class FakePrimitiveParam {
}
exports.FakePrimitiveParam = FakePrimitiveParam;
function isSQLWrapper(value) {
    return typeof value === 'object' && value !== null && 'getSQL' in value
        && typeof value.getSQL === 'function';
}
exports.isSQLWrapper = isSQLWrapper;
class SQL {
    constructor(queryChunks) {
        this.queryChunks = queryChunks;
        /** @internal */
        this.decoder = exports.noopDecoder;
    }
    append(chunk) {
        this.queryChunks.push(...chunk.queryChunks);
        return this;
    }
    toQuery({ escapeName, escapeParam, paramStartIndex = 0 }, prepareTyping) {
        const params = [];
        const typings = [];
        const chunks = this.queryChunks.map((chunk) => {
            if (typeof chunk === 'string') {
                return chunk;
            }
            if (chunk instanceof Name) {
                return escapeName(chunk.value);
            }
            if (chunk instanceof table_1.Table) {
                const schemaName = chunk[table_1.Table.Symbol.Schema];
                return typeof schemaName !== 'undefined'
                    ? escapeName(schemaName) + '.' + escapeName(chunk[table_1.Table.Symbol.Name])
                    : escapeName(chunk[table_1.Table.Symbol.Name]);
            }
            if (chunk instanceof column_1.Column) {
                return escapeName(chunk.table[table_1.Table.Symbol.Name]) + '.' + escapeName(chunk.name);
            }
            if (chunk instanceof Param) {
                const mappedValue = chunk.encoder.mapToDriverValue(chunk.value);
                if (mappedValue instanceof SQL) {
                    const mappedValueQuery = mappedValue.toQuery({ escapeName, escapeParam, paramStartIndex }, prepareTyping);
                    params.push(...mappedValueQuery.params);
                    if (prepareTyping && mappedValueQuery.typings)
                        typings.push(...mappedValueQuery.typings);
                    return mappedValueQuery.sql;
                }
                params.push(chunk.encoder.mapToDriverValue(chunk.value));
                if (typeof prepareTyping !== 'undefined')
                    typings.push(prepareTyping(chunk.encoder));
                return escapeParam(paramStartIndex + params.length - 1, chunk.value);
            }
            const err = new Error('Unexpected chunk type!');
            console.error(chunk);
            throw err;
        });
        const sqlString = chunks
            .join('')
            .trim();
        return { sql: sqlString, params, typings };
    }
    getSQL() {
        return this;
    }
    as(alias) {
        // TODO: remove with deprecated overloads
        if (typeof alias === 'undefined') {
            return this;
        }
        return new SQL.Aliased(this, alias);
    }
    mapWith(decoder) {
        if (typeof decoder === 'function') {
            this.decoder = { mapFromDriverValue: decoder };
        }
        else {
            this.decoder = decoder;
        }
        return this;
    }
}
exports.SQL = SQL;
/**
 * Any DB name (table, column, index etc.)
 */
class Name {
    constructor(value) {
        this.value = value;
    }
}
exports.Name = Name;
/**
 * Any DB name (table, column, index etc.)
 */
function name(value) {
    return new Name(value);
}
exports.name = name;
exports.noopDecoder = {
    mapFromDriverValue: (value) => value,
};
exports.noopEncoder = {
    mapToDriverValue: (value) => value,
};
exports.noopMapper = Object.assign(Object.assign({}, exports.noopDecoder), exports.noopEncoder);
/** Parameter value that is optionally bound to an encoder (for example, a column). */
class Param {
    /**
     * @param value - Parameter value
     * @param encoder - Encoder to convert the value to a driver parameter
     */
    constructor(value, encoder = exports.noopEncoder) {
        this.value = value;
        this.encoder = encoder;
    }
}
exports.Param = Param;
function param(value, encoder) {
    return new Param(value, encoder);
}
exports.param = param;
function buildChunksFromParam(param) {
    if (Array.isArray(param)) {
        const result = ['('];
        param.forEach((p, i) => {
            result.push(...buildChunksFromParam(p));
            if (i < param.length - 1) {
                result.push(', ');
            }
        });
        result.push(')');
        return result;
    }
    if (param instanceof SQL) {
        return param.queryChunks;
    }
    if (param instanceof SQL.Aliased && typeof param.fieldAlias !== 'undefined') {
        return [new Name(param.fieldAlias)];
    }
    if (param instanceof table_1.Table || param instanceof column_1.Column || param instanceof Name || param instanceof Param) {
        return [param];
    }
    if (param instanceof subquery_1.Subquery) {
        if (param[subquery_1.SubqueryConfig].isWith) {
            return [new Name(param[subquery_1.SubqueryConfig].alias)];
        }
        return ['(', ...param[subquery_1.SubqueryConfig].sql.queryChunks, ') ', new Name(param[subquery_1.SubqueryConfig].alias)];
    }
    if (isSQLWrapper(param)) {
        return ['(', ...param.getSQL().queryChunks, ')'];
    }
    if (param !== undefined) {
        return [new Param(param)];
    }
    return [];
}
/*
    The type of `params` is specified as `SQLSourceParam[]`, but that's slightly incorrect -
    in runtime, users won't pass `FakePrimitiveParam` instances as `params` - they will pass primitive values
    which will be wrapped in `Param` using `buildChunksFromParam(...)`. That's why the overload
    specify `params` as `any[]` and not as `SQLSourceParam[]`. This type is used to make our lives easier and
    the type checker happy.
*/
function sql(strings, ...params) {
    const queryChunks = [];
    if (params.length > 0 || (strings.length > 0 && strings[0] !== '')) {
        queryChunks.push(strings[0]);
    }
    params.forEach((param, paramIndex) => {
        queryChunks.push(...buildChunksFromParam(param));
        queryChunks.push(strings[paramIndex + 1]);
    });
    return new SQL(queryChunks);
}
exports.sql = sql;
(function (sql) {
    function empty() {
        return new SQL([]);
    }
    sql.empty = empty;
    function fromList(list) {
        return new SQL(list.map(buildChunksFromParam).flat(1));
    }
    sql.fromList = fromList;
    /**
     * Convenience function to create an SQL query from a raw string.
     * @param str The raw SQL query string.
     */
    function raw(str) {
        return new SQL([str]);
    }
    sql.raw = raw;
})(sql = exports.sql || (exports.sql = {}));
(function (SQL) {
    class Aliased {
        constructor(sql, fieldAlias) {
            this.sql = sql;
            this.fieldAlias = fieldAlias;
            /** @internal */
            this.isSubquerySelectionField = false;
        }
        getSQL() {
            return this.sql;
        }
        /** @internal */
        clone() {
            return new Aliased(this.sql, this.fieldAlias);
        }
    }
    SQL.Aliased = Aliased;
})(SQL = exports.SQL || (exports.SQL = {}));
class Placeholder {
    constructor(name) {
        this.name = name;
    }
}
exports.Placeholder = Placeholder;
function placeholder(name) {
    return new Placeholder(name);
}
exports.placeholder = placeholder;
function fillPlaceholders(params, values) {
    return params.map((p) => {
        if (p instanceof Placeholder) {
            if (!(p.name in values)) {
                throw new Error(`No value for placeholder "${p.name}" was provided`);
            }
            return values[p.name];
        }
        return p;
    });
}
exports.fillPlaceholders = fillPlaceholders;
//# sourceMappingURL=index.js.map