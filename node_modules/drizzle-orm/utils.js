"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapUpdateSet = exports.orderSelectedFields = exports.mapResultRow = exports.npmVersion = exports.apiVersion = void 0;
const column_1 = require("./column");
const sql_1 = require("./sql");
const table_1 = require("./table");
/**
 * @deprecated
 * Use `compatibilityVersion` from `drizzle-orm/version` instead.
 */
exports.apiVersion = 2;
/**
 * @deprecated
 * Use `npmVersion` from `drizzle-orm/version` instead.
 */
exports.npmVersion = '0.17.0';
function mapResultRow(columns, row, joinsNotNullableMap) {
    // Key -> nested object key, value -> table name if all fields in the nested object are from the same table, false otherwise
    const nullifyMap = {};
    const result = columns.reduce((result, { path, field }, columnIndex) => {
        let decoder;
        if (field instanceof column_1.Column) {
            decoder = field;
        }
        else if (field instanceof sql_1.SQL) {
            decoder = field.decoder;
        }
        else {
            decoder = field.sql.decoder;
        }
        let node = result;
        path.forEach((pathChunk, pathChunkIndex) => {
            if (pathChunkIndex < path.length - 1) {
                if (!(pathChunk in node)) {
                    node[pathChunk] = {};
                }
                node = node[pathChunk];
            }
            else {
                const rawValue = row[columnIndex];
                const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
                if (joinsNotNullableMap && field instanceof column_1.Column && path.length === 2) {
                    const objectName = path[0];
                    if (!(objectName in nullifyMap)) {
                        if (value === null) {
                            nullifyMap[objectName] = (0, table_1.getTableName)(field.table);
                        }
                        else {
                            nullifyMap[objectName] = false;
                        }
                    }
                    else if (typeof nullifyMap[objectName] === 'string' && nullifyMap[objectName] !== (0, table_1.getTableName)(field.table)) {
                        nullifyMap[objectName] = false;
                    }
                }
            }
        });
        return result;
    }, {});
    // Nullify all nested objects from nullifyMap that are nullable
    if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
        Object.entries(nullifyMap).forEach(([objectName, tableName]) => {
            if (typeof tableName === 'string' && !joinsNotNullableMap[tableName]) {
                result[objectName] = null;
            }
        });
    }
    return result;
}
exports.mapResultRow = mapResultRow;
function orderSelectedFields(fields, pathPrefix) {
    return Object.entries(fields).reduce((result, [name, field]) => {
        if (typeof name !== 'string') {
            return result;
        }
        const newPath = pathPrefix ? [...pathPrefix, name] : [name];
        if (field instanceof column_1.Column
            || field instanceof sql_1.SQL
            || field instanceof sql_1.SQL.Aliased) {
            result.push({ path: newPath, field });
        }
        else if (field instanceof table_1.Table) {
            result.push(...orderSelectedFields(field[table_1.Table.Symbol.Columns], newPath));
        }
        else {
            result.push(...orderSelectedFields(field, newPath));
        }
        return result;
    }, []);
}
exports.orderSelectedFields = orderSelectedFields;
/** @internal */
function mapUpdateSet(table, values) {
    return Object.fromEntries(Object.entries(values).map(([key, value]) => {
        if (value instanceof sql_1.SQL || value === null || value === undefined) {
            return [key, value];
        }
        else {
            return [key, new sql_1.Param(value, table[table_1.Table.Symbol.Columns][key])];
        }
    }));
}
exports.mapUpdateSet = mapUpdateSet;
//# sourceMappingURL=utils.js.map