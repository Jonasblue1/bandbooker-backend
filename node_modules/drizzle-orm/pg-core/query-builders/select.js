"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PgSelect = exports.PgSelectBuilder = void 0;
const query_promise_1 = require("../../query-promise");
const table_1 = require("../../table");
const subquery_1 = require("../../subquery");
const utils_1 = require("../../utils");
const utils_2 = require("../utils");
class PgSelectBuilder {
    constructor(fields, session, dialect, withList = []) {
        this.fields = fields;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
    }
    from(table) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
            fields = this.fields;
        }
        else if (table instanceof subquery_1.Subquery) {
            // This is required to use the proxy handler to get the correct field values from the subquery
            fields = Object.fromEntries(Object.keys(table[subquery_1.SubqueryConfig].selection).map((key) => [key, table[key]]));
        }
        else {
            fields = (0, utils_2.getTableColumns)(table, { format: 'object' });
        }
        const fieldsList = (0, utils_1.orderSelectedFields)(fields);
        return new PgSelect(table, fields, fieldsList, isPartialSelect, this.session, this.dialect, this.withList);
    }
}
exports.PgSelectBuilder = PgSelectBuilder;
class PgSelect extends query_promise_1.QueryPromise {
    constructor(table, fields, fieldsList, isPartialSelect, session, dialect, withList) {
        super();
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this.leftJoin = this.createJoin('left');
        this.rightJoin = this.createJoin('right');
        this.innerJoin = this.createJoin('inner');
        this.fullJoin = this.createJoin('full');
        this.execute = (placeholderValues) => {
            return this._prepare().execute(placeholderValues);
        };
        this.config = {
            withList,
            table,
            fields,
            fieldsList,
            joins: {},
            orderBy: [],
            groupBy: [],
            lockingClauses: [],
        };
        this.tableName = table instanceof subquery_1.Subquery ? table[subquery_1.SubqueryConfig].alias : table[table_1.Table.Symbol.Name];
        this.joinsNotNullable = { [this.tableName]: true };
    }
    createJoin(joinType) {
        return (table, on) => {
            const tableName = table instanceof subquery_1.Subquery ? table[subquery_1.SubqueryConfig].alias : table[table_1.Table.Symbol.Name];
            if (this.config.joins[tableName]) {
                throw new Error(`Alias "${tableName}" is already used in this query`);
            }
            if (!this.isPartialSelect) {
                // If this is the first join and this is not a partial select, "move" the fields from the main table to the nested object
                if (Object.keys(this.joinsNotNullable).length === 1) {
                    this.config.fieldsList = this.config.fieldsList.map((field) => (Object.assign(Object.assign({}, field), { path: [this.tableName, ...field.path] })));
                }
                this.config.fieldsList.push(...(0, utils_1.orderSelectedFields)(table instanceof subquery_1.Subquery ? table[subquery_1.SubqueryConfig].selection : table[table_1.Table.Symbol.Columns], [tableName]));
            }
            this.config.joins[tableName] = { on, table, joinType };
            switch (joinType) {
                case 'left':
                    this.joinsNotNullable[tableName] = false;
                    break;
                case 'right':
                    this.joinsNotNullable = Object.fromEntries(Object.entries(this.joinsNotNullable).map(([key]) => [key, false]));
                    this.joinsNotNullable[tableName] = true;
                    break;
                case 'inner':
                    this.joinsNotNullable[tableName] = true;
                    break;
                case 'full':
                    this.joinsNotNullable = Object.fromEntries(Object.entries(this.joinsNotNullable).map(([key]) => [key, false]));
                    this.joinsNotNullable[tableName] = false;
                    break;
            }
            return this;
        };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    groupBy(...columns) {
        this.config.groupBy = columns;
        return this;
    }
    orderBy(...columns) {
        this.config.orderBy = columns;
        return this;
    }
    limit(limit) {
        this.config.limit = limit;
        return this;
    }
    offset(offset) {
        this.config.offset = offset;
        return this;
    }
    for(strength, config = {}) {
        this.config.lockingClauses.push({ strength, config });
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildSelectQuery(this.config);
    }
    toSQL() {
        const _a = this.dialect.sqlToQuery(this.getSQL()), { typings } = _a, rest = __rest(_a, ["typings"]);
        return rest;
    }
    _prepare(name) {
        const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.fieldsList, name);
        query.joinsNotNullableMap = this.joinsNotNullable;
        return query;
    }
    prepare(name) {
        return this._prepare(name);
    }
    as(alias) {
        return new Proxy(new subquery_1.Subquery(this.getSQL(), this.config.fields, alias), new subquery_1.SubquerySelectionProxyHandler(alias));
    }
    prepareWithSubquery(alias) {
        return new Proxy(new subquery_1.WithSubquery(this.getSQL(), this.config.fields, alias, true), new subquery_1.SubquerySelectionProxyHandler(alias));
    }
}
exports.PgSelect = PgSelect;
//# sourceMappingURL=select.js.map