import { MigrationMeta } from '../migrator';
import { Query, SQL } from '../sql';
import { SQLiteDeleteConfig, SQLiteInsertConfig, SQLiteUpdateConfig } from './query-builders';
import { AnySQLiteTable } from './table';
import { UpdateSet } from '../utils';
import { SQLiteSelectConfig } from './query-builders/select.types';
import { SQLiteSession } from './session';
export declare abstract class SQLiteDialect {
    escapeName(name: string): string;
    escapeParam(num: number): string;
    buildDeleteQuery({ table, where, returning }: SQLiteDeleteConfig): SQL;
    buildUpdateSet(table: AnySQLiteTable, set: UpdateSet): SQL;
    buildUpdateQuery({ table, set, where, returning }: SQLiteUpdateConfig): SQL;
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    private buildSelection;
    buildSelectQuery({ withList, fieldsList: fields, where, table, joins, orderBy, groupBy, limit, offset }: SQLiteSelectConfig): SQL;
    buildInsertQuery({ table, values, onConflict, returning }: SQLiteInsertConfig): SQL;
    sqlToQuery(sql: SQL): Query;
}
export declare class SQLiteSyncDialect extends SQLiteDialect {
    migrate(migrations: MigrationMeta[], session: SQLiteSession<'sync'>): void;
}
export declare class SQLiteAsyncDialect extends SQLiteDialect {
    migrate(migrations: MigrationMeta[], session: SQLiteSession<'async'>): Promise<void>;
}
//# sourceMappingURL=dialect.d.ts.map