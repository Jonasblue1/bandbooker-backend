"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SQLiteAsyncDialect = exports.SQLiteSyncDialect = exports.SQLiteDialect = void 0;
const column_1 = require("../column");
const sql_1 = require("../sql");
const columns_1 = require("./columns");
const table_1 = require("./table");
const subquery_1 = require("../subquery");
const table_2 = require("../table");
class SQLiteDialect {
    escapeName(name) {
        return `"${name}"`;
    }
    escapeParam(num) {
        return '?';
    }
    buildDeleteQuery({ table, where, returning }) {
        const returningSql = returning
            ? (0, sql_1.sql) ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? (0, sql_1.sql) ` where ${where}` : undefined;
        return (0, sql_1.sql) `delete from ${table}${whereSql}${returningSql}`;
    }
    buildUpdateSet(table, set) {
        const setEntries = Object.entries(set);
        const setSize = setEntries.length;
        return sql_1.sql.fromList(setEntries
            .map(([colName, value], i) => {
            const col = table[table_2.Table.Symbol.Columns][colName];
            const res = (0, sql_1.sql) `${new sql_1.Name(col.name)} = ${value}`;
            if (i < setSize - 1) {
                return [res, sql_1.sql.raw(', ')];
            }
            return [res];
        })
            .flat(1));
    }
    buildUpdateQuery({ table, set, where, returning }) {
        const setSql = this.buildUpdateSet(table, set);
        const returningSql = returning
            ? (0, sql_1.sql) ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? (0, sql_1.sql) ` where ${where}` : undefined;
        return (0, sql_1.sql) `update ${table} set ${setSql}${whereSql}${returningSql}`;
    }
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields
            .map(({ field }, i) => {
            const chunk = [];
            if (field instanceof sql_1.SQL.Aliased && field.isSubquerySelectionField) {
                chunk.push(new sql_1.Name(field.fieldAlias));
            }
            else if (field instanceof sql_1.SQL.Aliased || field instanceof sql_1.SQL) {
                const query = field instanceof sql_1.SQL.Aliased ? field.sql : field;
                if (isSingleTable) {
                    chunk.push(new sql_1.SQL(query.queryChunks.map((c) => {
                        if (c instanceof columns_1.SQLiteColumn) {
                            return new sql_1.Name(c.name);
                        }
                        return c;
                    })));
                }
                else {
                    chunk.push(query);
                }
                if (field instanceof sql_1.SQL.Aliased) {
                    chunk.push((0, sql_1.sql) ` as ${new sql_1.Name(field.fieldAlias)}`);
                }
            }
            else if (field instanceof column_1.Column) {
                if (isSingleTable) {
                    chunk.push(new sql_1.Name(field.name));
                }
                else {
                    chunk.push(field);
                }
            }
            if (i < columnsLen - 1) {
                chunk.push((0, sql_1.sql) `, `);
            }
            return chunk;
        })
            .flat(1);
        return sql_1.sql.fromList(chunks);
    }
    buildSelectQuery({ withList, fieldsList: fields, where, table, joins, orderBy, groupBy, limit, offset }) {
        fields.forEach((f) => {
            let tableName;
            if (f.field instanceof column_1.Column
                && (0, table_2.getTableName)(f.field.table)
                    !== (table instanceof subquery_1.Subquery ? table[subquery_1.SubqueryConfig].alias : (0, table_2.getTableName)(table))
                && !((tableName = (0, table_2.getTableName)(f.field.table)) in joins)) {
                throw new Error(`Your "${f.path.join('->')}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
            }
        });
        const joinKeys = Object.keys(joins);
        const isSingleTable = joinKeys.length === 0;
        let withSql;
        if (withList.length) {
            const withSqlChunks = [(0, sql_1.sql) `with `];
            withList.forEach((w, i) => {
                withSqlChunks.push((0, sql_1.sql) `${new sql_1.Name(w[subquery_1.SubqueryConfig].alias)} as (${w[subquery_1.SubqueryConfig].sql})`);
                if (i < withList.length - 1) {
                    withSqlChunks.push((0, sql_1.sql) `, `);
                }
            });
            withSqlChunks.push((0, sql_1.sql) ` `);
            withSql = sql_1.sql.fromList(withSqlChunks);
        }
        const selection = this.buildSelection(fields, { isSingleTable });
        const joinsArray = [];
        joinKeys.forEach((tableAlias, index) => {
            if (index === 0) {
                joinsArray.push((0, sql_1.sql) ` `);
            }
            const joinMeta = joins[tableAlias];
            const table = joinMeta.table;
            if (table instanceof table_1.SQLiteTable) {
                const tableName = table[table_1.SQLiteTable.Symbol.Name];
                const tableSchema = table[table_1.SQLiteTable.Symbol.Schema];
                const origTableName = table[table_1.SQLiteTable.Symbol.OriginalName];
                const alias = tableName === origTableName ? undefined : tableAlias;
                joinsArray.push((0, sql_1.sql) `${sql_1.sql.raw(joinMeta.joinType)} join ${tableSchema ? (0, sql_1.sql) `${new sql_1.Name(tableSchema)}.` : undefined}${new sql_1.Name(origTableName)} ${alias && new sql_1.Name(alias)} on ${joinMeta.on}`);
            }
            else {
                joinsArray.push((0, sql_1.sql) `${sql_1.sql.raw(joinMeta.joinType)} join ${table} on ${joinMeta.on}`);
            }
            if (index < joinKeys.length - 1) {
                joinsArray.push((0, sql_1.sql) ` `);
            }
        });
        const joinsSql = sql_1.sql.fromList(joinsArray);
        const whereSql = where ? (0, sql_1.sql) ` where ${where}` : undefined;
        const orderByList = [];
        orderBy.forEach((orderByValue, index) => {
            orderByList.push(orderByValue);
            if (index < orderBy.length - 1) {
                orderByList.push((0, sql_1.sql) `, `);
            }
        });
        const groupByList = [];
        groupBy.forEach((groupByValue, index) => {
            groupByList.push(groupByValue);
            if (index < groupBy.length - 1) {
                groupByList.push((0, sql_1.sql) `, `);
            }
        });
        const groupBySql = groupByList.length > 0 ? (0, sql_1.sql) ` group by ${sql_1.sql.fromList(groupByList)}` : undefined;
        const orderBySql = orderByList.length > 0 ? (0, sql_1.sql) ` order by ${sql_1.sql.fromList(orderByList)}` : undefined;
        const limitSql = limit ? (0, sql_1.sql) ` limit ${limit}` : undefined;
        const offsetSql = offset ? (0, sql_1.sql) ` offset ${offset}` : undefined;
        return (0, sql_1.sql) `${withSql}select ${selection} from ${table}${joinsSql}${whereSql}${groupBySql}${orderBySql}${limitSql}${offsetSql}`;
    }
    buildInsertQuery({ table, values, onConflict, returning }) {
        const isSingleValue = values.length === 1;
        const valuesSqlList = [];
        const columns = table[table_2.Table.Symbol.Columns];
        const colEntries = isSingleValue
            ? Object.keys(values[0]).map((fieldName) => [fieldName, columns[fieldName]])
            : Object.entries(columns);
        const insertOrder = colEntries.map(([, column]) => new sql_1.Name(column.name));
        values.forEach((value, valueIndex) => {
            const valueList = [];
            colEntries.forEach(([fieldName, col]) => {
                const colValue = value[fieldName];
                if (typeof colValue === 'undefined') {
                    let defaultValue;
                    if (col.default !== null && col.default !== undefined) {
                        if (col.default instanceof sql_1.SQL) {
                            defaultValue = col.default;
                        }
                        else {
                            defaultValue = (0, sql_1.param)(col.default, col);
                        }
                    }
                    else {
                        defaultValue = (0, sql_1.sql) `null`;
                    }
                    valueList.push(defaultValue);
                }
                else {
                    valueList.push(colValue);
                }
            });
            valuesSqlList.push(valueList);
            if (valueIndex < values.length - 1) {
                valuesSqlList.push((0, sql_1.sql) `, `);
            }
        });
        const valuesSql = sql_1.sql.fromList(valuesSqlList);
        const returningSql = returning
            ? (0, sql_1.sql) ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const onConflictSql = onConflict ? (0, sql_1.sql) ` on conflict ${onConflict}` : undefined;
        return (0, sql_1.sql) `insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
    }
    sqlToQuery(sql) {
        return sql.toQuery({
            escapeName: this.escapeName,
            escapeParam: this.escapeParam,
        });
    }
}
exports.SQLiteDialect = SQLiteDialect;
class SQLiteSyncDialect extends SQLiteDialect {
    migrate(migrations, session) {
        var _a;
        const migrationTableCreate = (0, sql_1.sql) `CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
			id SERIAL PRIMARY KEY,
			hash text NOT NULL,
			created_at numeric
		)`;
        session.run(migrationTableCreate);
        const dbMigrations = session.values((0, sql_1.sql) `SELECT id, hash, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC LIMIT 1`);
        const lastDbMigration = (_a = dbMigrations[0]) !== null && _a !== void 0 ? _a : undefined;
        session.run((0, sql_1.sql) `BEGIN`);
        try {
            for (const migration of migrations) {
                if (!lastDbMigration || parseInt(lastDbMigration[2], 10) < migration.folderMillis) {
                    session.exec(migration.sql);
                    session.run((0, sql_1.sql) `INSERT INTO "__drizzle_migrations" ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
                }
            }
            session.run((0, sql_1.sql) `COMMIT`);
        }
        catch (e) {
            session.run((0, sql_1.sql) `ROLLBACK`);
            throw e;
        }
    }
}
exports.SQLiteSyncDialect = SQLiteSyncDialect;
class SQLiteAsyncDialect extends SQLiteDialect {
    migrate(migrations, session) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const migrationTableCreate = (0, sql_1.sql) `CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
			id SERIAL PRIMARY KEY,
			hash text NOT NULL,
			created_at numeric
		)`;
            yield session.run(migrationTableCreate);
            const dbMigrations = yield session.values((0, sql_1.sql) `SELECT id, hash, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC LIMIT 1`);
            const lastDbMigration = (_a = dbMigrations[0]) !== null && _a !== void 0 ? _a : undefined;
            yield session.run((0, sql_1.sql) `BEGIN`);
            try {
                for (const migration of migrations) {
                    if (!lastDbMigration || parseInt(lastDbMigration[2], 10) < migration.folderMillis) {
                        yield session.run(sql_1.sql.raw(migration.sql));
                        yield session.run((0, sql_1.sql) `INSERT INTO "__drizzle_migrations" ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
                    }
                }
                yield session.run((0, sql_1.sql) `COMMIT`);
            }
            catch (e) {
                yield session.run((0, sql_1.sql) `ROLLBACK`);
                throw e;
            }
        });
    }
}
exports.SQLiteAsyncDialect = SQLiteAsyncDialect;
//# sourceMappingURL=dialect.js.map